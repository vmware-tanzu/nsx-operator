package subnetbinding

import (
	"context"
	"sync"

	"github.com/vmware/vsphere-automation-sdk-go/services/nsxt/model"
	"k8s.io/apimachinery/pkg/util/sets"

	"github.com/vmware-tanzu/nsx-operator/pkg/apis/vpc/v1alpha1"
	"github.com/vmware-tanzu/nsx-operator/pkg/logger"
	servicecommon "github.com/vmware-tanzu/nsx-operator/pkg/nsx/services/common"
)

const (
	hAPIPageSize = 1000
)

var (
	log                                    = &logger.Log
	ResourceTypeSubnetConnectionBindingMap = servicecommon.ResourceTypeSubnetConnectionBindingMap
	enforceRevisionCheckParam              = false
)

type BindingService struct {
	servicecommon.Service
	BindingStore *BindingStore
}

// InitializeService initializes SubnetConnectionBindingMap service.
func InitializeService(service servicecommon.Service) (*BindingService, error) {
	wg := sync.WaitGroup{}
	fatalErrors := make(chan error, 1)
	defer close(fatalErrors)

	bindingService := &BindingService{
		Service:      service,
		BindingStore: SetupStore(),
	}

	wg.Add(1)
	go service.InitializeResourceStore(&wg, fatalErrors, ResourceTypeSubnetConnectionBindingMap, nil, bindingService.BindingStore)
	wg.Wait()

	if len(fatalErrors) > 0 {
		err := <-fatalErrors
		return bindingService, err
	}

	return bindingService, nil
}

// CreateOrUpdateSubnetConnectionBindingMap creates or updates the SubnetConnectionBindingMaps with the given
// SubnetConnectionBindingMap CR and attaches it to the parentSubnets.
func (s *BindingService) CreateOrUpdateSubnetConnectionBindingMap(
	subnetBinding *v1alpha1.SubnetConnectionBindingMap,
	childSubnet *model.VpcSubnet,
	parentSubnets []*model.VpcSubnet) error {
	desiredBMmap := bindingMapsToMap(s.buildSubnetBindings(subnetBinding, parentSubnets))
	existingBMmap := bindingMapsToMap(s.BindingStore.getBindingsByBindingMapCRUID(string(subnetBinding.UID)))
	updatedBindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	for k, v := range desiredBMmap {
		existBindingMap, found := existingBMmap[k]
		if !found {
			updatedBindingMaps = append(updatedBindingMaps, v)
			continue
		}
		changed := servicecommon.CompareResource(SubnetConnectionBindingMapToComparable(existBindingMap), SubnetConnectionBindingMapToComparable(v))
		if changed {
			updatedBindingMaps = append(updatedBindingMaps, v)
		}
	}
	// Mark the SubnetConnectionBindingMap as for-delete if it exists in the store but does not exist in the desired resources.
	for k, v := range existingBMmap {
		_, found := desiredBMmap[k]
		if !found {
			toDelBindingMap := *v
			toDelBindingMap.MarkedForDelete = Bool(true)
			updatedBindingMaps = append(updatedBindingMaps, &toDelBindingMap)
		}
	}

	if err := s.Apply(*childSubnet.Path, updatedBindingMaps); err != nil {
		return err
	}

	return nil
}

// DeleteSubnetConnectionBindingMapsByCRName deletes all the SubnetConnectionBindingMaps generated by the given subnetBinding
// CR's Name.
func (s *BindingService) DeleteSubnetConnectionBindingMapsByCRName(bindingName string, bindingNamespace string) error {
	bindingMaps := s.BindingStore.getBindingsByBindingMapCRName(bindingName, bindingNamespace)
	return s.deleteSubnetConnectionBindingMaps(bindingMaps)
}

// DeleteSubnetConnectionBindingMapsByParentSubnet deletes all the SubnetConnectionBindingMaps bound to the
// given parentSubnet.
func (s *BindingService) DeleteSubnetConnectionBindingMapsByParentSubnet(parentSubnet *model.VpcSubnet) error {
	bindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	// This should not happen in the production setup, adding this check is for security.
	if parentSubnet.Path == nil {
		log.Info("Parent VpcSubnet had no configured Path, ignoring", "subnet", *parentSubnet.Id)
		return nil
	}
	subnetPath := *parentSubnet.Path
	bindingMaps = append(bindingMaps, s.BindingStore.getBindingsByParentSubnet(subnetPath)...)
	return s.deleteSubnetConnectionBindingMaps(bindingMaps)
}

// GetSubnetConnectionBindingMapsBySubnet returns all the SubnetConnectionBindingMaps referred to the given subnet.
// The function returns the SubnetConnectionBindingMaps associated with the subnet if exists, otherwise it returns
// the SubnetConnectionBindingMaps connected to the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsBySubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	bindingMapsByChild := s.GetSubnetConnectionBindingMapsByChildSubnet(subnet)
	if len(bindingMapsByChild) > 0 {
		return bindingMapsByChild
	}
	return s.GetSubnetConnectionBindingMapsByParentSubnet(subnet)
}

// GetSubnetConnectionBindingMapsByChildSubnet returns the SubnetConnectionBindingMaps associated with the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsByChildSubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	return s.BindingStore.getBindingsByChildSubnet(*subnet.Path)
}

// GetSubnetConnectionBindingMapsByParentSubnet returns the SubnetConnectionBindingMaps connected to the subnet.
func (s *BindingService) GetSubnetConnectionBindingMapsByParentSubnet(subnet *model.VpcSubnet) []*model.SubnetConnectionBindingMap {
	return s.BindingStore.getBindingsByParentSubnet(*subnet.Path)
}

func (s *BindingService) GetSubnetConnectionBindingMapCRsBySubnet(subnet *model.VpcSubnet) []*v1alpha1.SubnetConnectionBindingMap {
	nsxBindingMaps := s.GetSubnetConnectionBindingMapsBySubnet(subnet)
	if len(nsxBindingMaps) == 0 {
		return nil
	}

	subnetConnectionBindingMaps := sets.New[*v1alpha1.SubnetConnectionBindingMap]()
	for _, bm := range nsxBindingMaps {
		obj, err := buildSubnetConnectionBindingMapCR(bm)
		if err != nil {
			log.Error(err, "Unable to get SubnetConnectionBindingMap CR from NSX resource", "SubnetConnectionBindingMap", *bm.Id)
			continue
		}
		subnetConnectionBindingMaps.Insert(obj)
	}
	return subnetConnectionBindingMaps.UnsortedList()
}

func (s *BindingService) ListSubnetConnectionBindingMapCRUIDsInStore() sets.Set[string] {
	crUIDs := sets.New[string]()
	for _, obj := range s.BindingStore.List() {
		bm, _ := obj.(*model.SubnetConnectionBindingMap)
		res, err := buildSubnetConnectionBindingMapCR(bm)
		if err != nil {
			log.Error(err, "Unable to get SubnetConnectionBindingMap CR from NSX resource", "bindingMap", *bm.Id)
			continue
		}
		crUIDs.Insert(string(res.UID))
	}
	return crUIDs
}

// Apply sync bindingMaps on NSX and save into the store if succeeded to realize.
func (s *BindingService) Apply(subnetPath string, bindingMaps []*model.SubnetConnectionBindingMap) error {
	return s.hUpdateSubnetConnectionBindingMaps(subnetPath, bindingMaps)
}

// deleteSubnetConnectionBindingMaps uses HAPI call to delete multiple SubnetConnectionBindingMaps on NSX in one
// transaction, and then delete these resources from local store. Since NSX can accept no more than 5K children Nodes
// in one HAPI call, paging is used in this function to avoid scale issues.
func (s *BindingService) deleteSubnetConnectionBindingMaps(bindingMaps []*model.SubnetConnectionBindingMap) error {
	// Add this check for security purpose. The caller has similar pre-check and returned if no items exist in the bindingMaps.
	bindingMapsCount := len(bindingMaps)
	if bindingMapsCount == 0 {
		log.Info("No existing SubnetConnectionBindingMaps found in the store")
		return nil
	}
	pages := (bindingMapsCount + hAPIPageSize - 1) / hAPIPageSize
	for i := 1; i <= pages; i++ {
		start := (i - 1) * hAPIPageSize
		end := start + hAPIPageSize
		if end > bindingMapsCount {
			end = bindingMapsCount
		}
		if err := s.hDeleteSubnetConnectionBindingMap(bindingMaps[start:end]); err != nil {
			return err
		}
	}
	return nil
}

func (s *BindingService) DeleteMultiSubnetConnectionBindingMapsByCRs(bindingCRs sets.Set[string]) error {
	if bindingCRs.Len() == 0 {
		return nil
	}
	finalBindingMaps := make([]*model.SubnetConnectionBindingMap, 0)
	for _, crID := range bindingCRs.UnsortedList() {
		bms := s.BindingStore.getBindingsByBindingMapCRUID(crID)
		finalBindingMaps = append(finalBindingMaps, bms...)
	}
	return s.deleteSubnetConnectionBindingMaps(finalBindingMaps)
}

func (s *BindingService) GetSubnetConnectionBindingMapCRName(bindingMap *model.SubnetConnectionBindingMap) string {
	if bindingMap == nil {
		return ""
	}
	for _, tag := range bindingMap.Tags {
		if *tag.Scope == servicecommon.TagScopeSubnetBindingCRName {
			return *tag.Tag
		}
	}
	return ""
}

func (s *BindingService) Cleanup(ctx context.Context) error {
	allNSXBindings := s.BindingStore.List()
	log.Info("Cleaning up SubnetConnectionBindingMaps", "Count", len(allNSXBindings))
	finalBindingMaps := make([]*model.SubnetConnectionBindingMap, len(allNSXBindings))
	for i, obj := range allNSXBindings {
		binding, _ := obj.(*model.SubnetConnectionBindingMap)
		finalBindingMaps[i] = binding
	}

	return s.deleteSubnetConnectionBindingMaps(finalBindingMaps)
}

func bindingMapsToMap(bindingMaps []*model.SubnetConnectionBindingMap) map[string]*model.SubnetConnectionBindingMap {
	bmMap := make(map[string]*model.SubnetConnectionBindingMap)
	for _, bm := range bindingMaps {
		bmMap[*bm.Id] = bm
	}
	return bmMap
}
